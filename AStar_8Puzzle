import heapq

# -----------------------------
# 1. Manhattan Distance Heuristic
# -----------------------------
def manhattan(state):
    dist = 0
    for i in range(9):
        if state[i] == 0:
            continue
        x1, y1 = i // 3, i % 3     # current position
        x2, y2 = (state[i]-1) // 3, (state[i]-1) % 3   # goal position
        dist += abs(x1 - x2) + abs(y1 - y2)
    return dist


# -----------------------------
# 2. Display Board
# -----------------------------
def print_board(state):
    print()
    for i in range(0, 9, 3):
        print(state[i], state[i+1], state[i+2])
    print()


# -----------------------------
# 3. Generate Possible Moves
# -----------------------------
def get_neighbors(state):
    neighbors = []
    s = list(state)
    zero_index = s.index(0)
    x, y = zero_index // 3, zero_index % 3

    moves = {
        "UP": (x - 1, y),
        "DOWN": (x + 1, y),
        "LEFT": (x, y - 1),
        "RIGHT": (x, y + 1)
    }

    for move, (nx, ny) in moves.items():
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_s = s.copy()
            new_index = nx * 3 + ny
            new_s[zero_index], new_s[new_index] = new_s[new_index], new_s[zero_index]
            neighbors.append((tuple(new_s), move))

    return neighbors


# -----------------------------
# 4. A* Algorithm
# -----------------------------
def a_star(start, goal):

    open_list = []
    heapq.heappush(open_list, (manhattan(start), 0, start, []))

    visited = set()

    while open_list:
        f, g, current, path = heapq.heappop(open_list)

        print("Expanding node with f =", f, " g =", g)
        print_board(current)

        if current == goal:
            print("Goal Reached!")
            return path + [current]

        if current in visited:
            continue

        visited.add(current)

        for neighbor, move in get_neighbors(current):
            if neighbor not in visited:
                new_g = g + 1
                new_f = new_g + manhattan(neighbor)
                heapq.heappush(open_list, (new_f, new_g, neighbor, path + [current]))


# -----------------------------
# 5. RUNNING THE SOLVER
# -----------------------------
goal_state = (1,2,3,
              4,5,6,
              7,8,0)

# GOOD input with moderate steps (does not explode)
start_state = (1,2,3,
               4,5,6,
               0,7,8)

print("Start State:")
print_board(start_state)

solution = a_star(start_state, goal_state)

print("\nSolution Path:")
step = 0
for s in solution:
    print("Step", step)
    print_board(s)
    step += 1

print("Total Moves =", step - 1)
